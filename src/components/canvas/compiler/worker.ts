/**
 * Web Worker for runtime JSX/TSX compilation via esbuild-wasm.
 *
 * Responsibilities:
 *  1. Lazy-load esbuild-wasm on first compile request
 *  2. Rewrite import statements to scope lookups (before esbuild)
 *  3. Inject loop guards to prevent infinite loops
 *  4. Transform TSX via esbuild
 */

let esbuildInitialized = false
let esbuildModule: typeof import('esbuild-wasm') | null = null

const MAX_ITERATIONS = 10_000

/**
 * Rewrite `import ... from '...'` to `const ... = __scope['...']`
 * Handles: default, named, namespace, and side-effect imports.
 */
const rewriteImports = (source: string): string => {
  // Match import statements - handles multiline
  return source.replace(
    /import\s+([\s\S]*?)\s+from\s+['"]([^'"]+)['"]\s*;?/g,
    (_match, specifiers: string, moduleName: string) => {
      const trimmed = specifiers.trim()

      // Namespace import: import * as Foo from 'bar'
      const nsMatch = trimmed.match(/^\*\s+as\s+(\w+)$/)
      if (nsMatch) {
        return `const ${nsMatch[1]} = __scope['${moduleName}'];`
      }

      // Default + named: import Foo, { bar, baz as qux } from 'bar'
      const mixedMatch = trimmed.match(/^(\w+)\s*,\s*\{([^}]*)\}$/)
      if (mixedMatch) {
        const defaultName = mixedMatch[1]
        const named = mixedMatch[2]
        return `const ${defaultName} = __scope['${moduleName}'].default ?? __scope['${moduleName}']; const {${named}} = __scope['${moduleName}'];`
      }

      // Default only: import Foo from 'bar'
      if (/^\w+$/.test(trimmed)) {
        return `const ${trimmed} = __scope['${moduleName}'].default ?? __scope['${moduleName}'];`
      }

      // Named only: import { foo, bar as baz } from 'bar'
      const namedMatch = trimmed.match(/^\{([^}]*)\}$/)
      if (namedMatch) {
        return `const {${namedMatch[1]}} = __scope['${moduleName}'];`
      }

      // Side-effect import: import 'bar'  (drop it)
      return `/* side-effect import '${moduleName}' skipped */`
    },
  )
}

/**
 * Inject iteration guards into for/while/do-while loops.
 * Inserts a counter check that throws after MAX_ITERATIONS.
 */
const injectLoopGuards = (source: string): string => {
  let guardId = 0

  // Match for/while/do-while loop heads followed by `{`
  return source.replace(
    /((?:for|while)\s*\([^)]*\)\s*\{|do\s*\{)/g,
    (match) => {
      const id = `__guard${guardId++}`
      return `${match} var ${id} = 0; if (++${id} > ${MAX_ITERATIONS}) throw new Error("Loop exceeded ${MAX_ITERATIONS} iterations"); `
    },
  )
}

const initEsbuild = async () => {
  if (esbuildInitialized && esbuildModule) return esbuildModule

  esbuildModule = await import('esbuild-wasm')

  await esbuildModule.initialize({
    wasmURL: '/node_modules/esbuild-wasm/esbuild.wasm',
  })

  esbuildInitialized = true
  return esbuildModule
}

const compile = async (source: string): Promise<{ code: string } | { error: string }> => {
  try {
    const esbuild = await initEsbuild()

    // Step 1: Rewrite imports to scope lookups
    const rewritten = rewriteImports(source)

    // Step 2: Inject loop guards
    const guarded = injectLoopGuards(rewritten)

    // Step 3: Transform TSX â†’ JS via esbuild
    const result = await esbuild.transform(guarded, {
      loader: 'tsx',
      jsx: 'automatic',
      jsxImportSource: '__scope_jsx',
      target: 'es2020',
      format: 'esm',
    })

    // Step 4: Rewrite jsx-runtime imports generated by esbuild
    let code = result.code
    // esbuild generates: import { jsx, jsxs, Fragment } from '__scope_jsx/jsx-runtime'
    code = code.replace(
      /import\s*\{([^}]*)\}\s*from\s*['"]__scope_jsx\/jsx-runtime['"]\s*;?/g,
      (_m, names: string) => `const {${names}} = __scope['react/jsx-runtime'];`,
    )

    // Remove any remaining import/export statements
    code = code.replace(/^export\s+default\s+/m, '__exports.default = ')
    code = code.replace(/^export\s+/gm, '')

    return { code }
  } catch (err) {
    return { error: (err as Error).message }
  }
}

// Message handler
self.onmessage = async (event: MessageEvent<{ id: string; source: string }>) => {
  const { id, source } = event.data
  const result = await compile(source)
  self.postMessage({ id, ...result })
}
